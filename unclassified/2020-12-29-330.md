---
title: Leetcode每日一题：330.按要求补齐数组
tags: ["Leetcode","C++"]
---

前言：十二月因为期末了，课业压力比较大，所以每天就水水题，不会就快速抄答案完成打开，没有坚持写每日 leetcode 笔记。今天不知怎得，状态比较好，独立写出了这道困难题(我太菜了，能独立写出来的困难题寥寥无几)，所以赶紧记录下来分享解题过程。

分析题意，我的第一个问题是，如何确定 [1,n]区间中我们缺少的数？当时有两个想法如下：

* 最简单暴力的，遍历 nums 数组的元素的所有组合的和，现然这样代价非常大，而且之后填补数字后又要重新算。
* 前缀和，计算最大能表示的数，然后填补空缺

用前缀和具体怎么做呢，我想了好久好久，总之就是不断尝试，推导，最后得出了方法。

比如示例 nums = [1,5,10]，对前缀子数组 [1]，和为 1 ，最大能表示到 1，但下一个数字是 5 ，1 和 5 中间有空缺，空缺怎么弥补呢，添加数字，怎么确定添加数字？，我们可以尝试从 1 和 5 中间空缺的最小值开始添加，那我们添加 2 ，此时子数组为 [1,2]，和为 3，最大能表示到 3，那我们还缺 4 ，添加 4 就好了。到这里，仅用 [1,2,4]前缀子数组为 [1,2,4]，就可以最大表示到 7，比 5 大了，无需再填补空缺了，而此时我们加入 5 ，等于能表示在此前能表示的数的基础上加 5 的数，最大可以表示到 12 了，12 比下一个元素 10大了，直接加入 10，那我们最大可以表示到 22 了，比给定的 n = 20 大了，完成任务，添加 2 和 4 即可。

为什么这样的想法是最少的需要补充的数字？我没有想出很好的完整的证明，我的理解是，空缺的最小值，是最小的不能由添加别的数字来表示的数字，当添加空缺的最小值并更新前缀和时，也完成了对那些需要空缺的最小值来表示的数字的表示。比如上述示例中，1 和 5有三个空缺{2,3,4}，如果添加数字 3，数字 2 无法被表示，但添加数字 2，数字 3也可以被表示了。

综上，我们可以得到一个大致思路：维护一个前缀和，小于遍历到的当前元素时，添加空缺值且更新前缀和，直到前缀和大于或等于当前元素，大于或等于当前元素时，前缀和更新(加上当前元素)，继续遍历下一个元素。

~~~c++
for(auto i : nums){
    while(i > sum+1){	//为什么是 sum+1 不是 sum ，因为如果 i = sum+1 的话，其实就是没有空缺了
        sum += sum+1;	//空缺的最小值就是后面第一个不能被表示的数字
        cnt++;			//记录补充的数字个数
    }
    sum += i;
}
~~~

到这里其实已经差不多了，但要过题的话还需要一些细节补充

* 经过我的提交，发现 sum 有可能溢出 int ，所以改成 long long 吧
* 有可能出现只需要 nums 的前一部分元素就可以表示到 n 了，所以中途需要跳出
* 有可能用完 nums 的所有元素都不能表示到 n ，所以还要再处理一下

最后完整代码如下：

~~~c++
class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        int cnt = 0;
        long long sum = 0;
        for(auto i : nums){
            while(i > sum+1 && sum < n){
                cout << sum+1 << endl;
                sum += sum+1;
                cnt++;
            }
            if(sum > n)
                break;
            sum += i;
        }
        while(sum < n){
            sum += sum+1;
            cnt++;
        }
        return cnt;
    }
};
~~~

111