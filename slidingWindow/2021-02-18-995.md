---
title：Leetcode每日一题：995.K 连续位的最小翻转次数
tags: ["Leetcode","C++"]
---

* 对于若干个 K 位翻转操作，改变先后顺序并不影响最终翻转的结果。

  比如，从左往右遍历，先翻转从第 i 位开始的 K 位，再翻转从第 i+1 位开始的 K 位，虽然从第 i+1 位开始的 K-1 位实际上没有翻转，但第 i 位翻转了，即后续的翻转不影响前面的翻转，从右往左遍历也是同理，所以先后顺序不影响翻转结果。

* 由于对同一个子数组执行两次翻转操作不会改变该子数组，所以对每个长度为 K 的子数组，应至多执行一次翻转操作。

按照上述思想，我们从左到右地执行翻转操作。由于翻转操作是唯一的，若最终数组元素均为 1，则执行的翻转次数就是最小的。也就是贪心。

整体的思路就是贪心，当前是1不翻转，是0就翻转，一直到最后，如果在最后K个数范围内还有0，那没办法了，直接返回-1，每次翻转前要统计已经翻转的次数，这个次数并不是累加的，举个例子，如果k是2，第一个数是0，第二个数是1，那么首先翻转第一个K长度数组，变成了[1 ,0]，这个时候统计翻转次数的reverse数组要更新，将 0 + 2 位置的值-1，意思是从这开始没有翻转，相对于前一个k范围数组少翻转一次，计算到这时要减去1，每翻转一次就要更新当前翻转次数，即 cur++，所以总而言之，i + k 位置相当于标记，指明从这开始少翻转 reverse[i + k] 次。

## 差分数组

考虑不去翻转数字，而是统计每个数字需要翻转的次数。对于一次翻转操作，相当于把子数组中所有数字的翻转次数加 1。

这启发我们用差分数组的思想来计算当前数字需要翻转的次数。我们可以维护一个差分数组 diff，其中 diff[i] 表示两个相邻元素 A[i−1] 和 A[i] 的翻转次数的差，对于区间 [l,r]，将其元素全部加 1，只会影响到 l 和 r+1 处的差分值，故 diff[l] 增加 1，diff[r+1] 减少 1。

通过累加差分数组可以得到当前位置需要翻转的次数，我们用变量 revCnt 来表示这一累加值。

遍历到 A[i] 时，若 A[i]+revCnt 是偶数，则说明当前元素的实际值为 0，需要翻转区间 [i,i+K−1]，我们可以直接将 revCnt 增加 1，diff[i+K] 减少 1。

注意到若 i+K>n 则无法执行翻转操作，此时应返回 −1。

~~~c++
class Solution {
public:
    int minKBitFlips(vector<int> &A, int K) {
        int n = A.size();
        vector<int> diff(n + 1);
        int ans = 0, revCnt = 0;
        for (int i = 0; i < n; ++i) {
            revCnt += diff[i];
            if ((A[i] + revCnt) % 2 == 0) {
                if (i + K > n) {
                    return -1;
                }
                ++ans;
                ++revCnt;
                --diff[i + K];
            }
        }
        return ans;
    }
};
~~~

时间复杂度：O(N)，其中 N 是数组 AA 的长度。需要对数组 A 遍历一次。

空间复杂度：O(N)，其中 N 是数组 AA 的长度。需要创建一个长度为 N+1 的差分数组 \textit{diff}diff。

## 滑动窗口

提高内存执行效率，可以不用reverse数组，那如何标记呢？这就要利用到题中所给的A数组，因为数组中值的范围为0或者1，所以只要把A数组中对应位置的值更新到大于1即可作为标记。

具体来说，若要翻转从位置 i 开始的子数组，可以将 A[i] 加 2，这样当遍历到位置 i'  时，若有 A[i'-K]>1，则说明在位置 i'-K 上发生了翻转操作。

~~~c++
class Solution {
public:
    int minKBitFlips(vector<int>& A, int K) {
        int n = A.size();
        int ans = 0; // 记录翻转次数
        int cur = 0; // 记录当前位置翻转次数
        for(int i = 0; i < n; i++){
            if(i >= K && A[i-K] > 1){
                cur--; // 第 i-K 位开始的 K 位翻转，没有影响第 i 位及之后的位
                A[i-K] -= 2;
            }
            if((cur + A[i]) % 2 == 0) { // 当前位置为 0 ，翻转
                if(i + K > n) // 超出范围，无法翻转为全 1
                    return -1;
                ans++;
                cur++;
                A[i] += 2;
            }
        }
        return ans;
    }
};
~~~

